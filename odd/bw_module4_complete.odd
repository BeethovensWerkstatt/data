<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?><?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="mei-customizations.sch" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<TEI xmlns:rng="http://relaxng.org/ns/structure/1.0"
   xmlns:sch="http://purl.oclc.org/dsdl/schematron"
   xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://www.tei-c.org/ns/1.0">
   <teiHeader>
      <fileDesc>
         <titleStmt>
            <title>Beethovens Werkstatt Data Model Customization</title>
            <respStmt>
               <resp>Authored by</resp>
               <name xml:id="JK">Johannes Kepper</name>
            </respStmt>
         </titleStmt>
         <publicationStmt>
            <publisher>
            </publisher>
            <date when="2023"/>
            <availability>
               <licence target="http://creativecommons.org/licenses/by-sa/4.0/">
                  Creative Commons Attribution-ShareAlike 4.0 International </licence>
            </availability>
         </publicationStmt>
         <sourceDesc>
            <p>Original work by the Beethovens Werkstatt, but inspired by the great work of many other projects.</p>
         </sourceDesc>
      </fileDesc>
      <revisionDesc>
         <change n="1" when="2023-05-05" who="#JK">
            <desc>Initial setup of the ODD.</desc>
         </change>
      </revisionDesc>
   </teiHeader>
   <text>
      <body>
         <schemaSpec ident="mei" ns="http://www.music-encoding.org/ns/mei" prefix="mei_"
            start="mei">
            <!-- Declare MEI and XLink namespaces for use in Schematron -->
            <constraintSpec ident="set_ns" scheme="schematron" mode="add">
               <constraint>
                  <sch:ns xmlns:sch="http://purl.oclc.org/dsdl/schematron" prefix="mei"
                     uri="http://www.music-encoding.org/ns/mei"/>
                  <sch:ns xmlns:sch="http://purl.oclc.org/dsdl/schematron" prefix="xlink"
                     uri="http://www.w3.org/1999/xlink"/>
                  <sch:ns xmlns:sch="http://purl.oclc.org/dsdl/schematron" prefix="svg"
                     uri="http://www.w3.org/2000/svg"/>
                  <sch:ns xmlns:sch="http://purl.oclc.org/dsdl/schematron" prefix="tei"
                     uri="http://www.tei-c.org/ns/1.0"/>
                  <sch:ns xmlns:sch="http://purl.oclc.org/dsdl/schematron" prefix="bw"
                     uri="https://www.beethovens-werkstatt.de/ns/mei/proposal"/>
               </constraint>
            </constraintSpec>
            <!-- Include all modules -->
            <moduleRef key="MEI"/>
            <moduleRef key="MEI.analytical"/>
            <moduleRef key="MEI.cmn"
               except="beamSpan bend bracketSpan breath meterSigGrp mNum tupletSpan"/>
            <moduleRef key="MEI.cmnOrnaments"/>
            <moduleRef key="MEI.drama" except="sp"/>
            <moduleRef key="MEI.externalsymbols"/>
            <moduleRef key="MEI.facsimile"/>
            <moduleRef key="MEI.figtable" except="fig figDesc table td th tr"/>
            <moduleRef key="MEI.fingering"/>
            <moduleRef key="MEI.frbr"/>
            <moduleRef key="MEI.genetic"/>
            <moduleRef key="MEI.gestural"/>
            <moduleRef key="MEI.harmony" except="chordDef chordMember chordTable"/>
            <moduleRef key="MEI.header"
               except="componentList acquisition altId attUsage audience byline captureMode carrierForm catRel classification condition contentItem contents context cutout editionStmt exhibHist extMeta fileChar hand handList history incipCode incipText inscription key mensuration meter namespace notesStmt otherChar patch perfDuration physMedium playingSpeed price provenance segmentation soundChan specRepro stdVals sysReq tagsDecl tagUsage termList trackConfig treatHist treatSched useRestrict watermark"/>
            <moduleRef key="MEI.lyrics"/>
            <moduleRef key="MEI.msDesc" include="layoutDesc layout"/>
            <moduleRef key="MEI.namesdates"
               except="addName bloc country district famName foreName genName geogFeat nameLink periodName postBox postCode region roleName settlement street styleName"/>
            <moduleRef key="MEI.ptrref"/>
            <moduleRef key="MEI.shared"
               except="actor address addrLine ambitus ambNote analytic annot author barLine caption castGrp castItem cb castList colLayout contributor custos depth dim dimensions distributor div dot edition event eventList expansion extent genre group height imprint incip keyAccid lg librettist monogr pad pgDesc pgFoot pgHead phrase recipient relatedItem role roleDesc speaker sponsor stack term textLang titlePage titlePart width"/>
            <moduleRef key="MEI.usersymbols"
               except="anchoredText curve line mapping propName propValue"/>
            <moduleRef key="MEI.visual"/>
            
            <!-- Include SVG -->
            <moduleRef url="https://www.tei-c.org/release/xml/tei/custom/schema/relaxng/svg11.rng"
               prefix="svg_">
               <content>
                  <rng:define name="mei_model.graphicLike" combine="choice">
                     <rng:ref name="svg_svg"/>
                  </rng:define>
               </content>
            </moduleRef>
            <!--  ../rng/tei_bw.rng -->
            <moduleRef url="https://tei-c.org/release/xml/tei/custom/schema/relaxng/tei_all.rng"
               prefix="tei_">
               <content>
                  <rng:define name="mei_model.divLike" combine="choice">
                     <rng:ref name="tei_div"/>
                  </rng:define>
                  <rng:define name="tei_model.noteLike" combine="choice">
                     <rng:choice>
                        <rng:ref name="mei_metaMark"/>
                        <rng:ref name="mei_annot"/>  
                     </rng:choice>
                  </rng:define>
                  <rng:define name="tei_notatedMusic" combine="choice">
                     <!-- allow complete music examples to be embedded in notatedMusic -->
                     <rng:element name="notatedMusic">
                        <rng:zeroOrMore>
                           <rng:choice>
                              <rng:ref name="tei_model.labelLike"/>
                              <!--<rng:ref name="tei_model.ptrLike"/>-->
                              <rng:ref name="tei_graphic"/>
                              <rng:ref name="mei_section"/>
                              <!--<rng:ref name="tei_binaryObject"/>-->
                              <!--<rng:ref name="tei_seg"/>-->
                           </rng:choice>
                        </rng:zeroOrMore>
                        <rng:ref name="tei_att.global.attributes"/>
                        <rng:ref name="tei_att.placement.attributes"/>
                        <rng:ref name="tei_att.typed.attributes"/>
                        <rng:empty/>
                     </rng:element>  
                  </rng:define>
               </content>
            </moduleRef>
            
            <elementSpec ident="section" module="MEI.shared" mode="change">
               <constraintSpec ident="section_in_tei" scheme="schematron" mode="add">
                  <constraint>
                     <sch:rule context="mei:section[parent::tei:notatedMusic]">
                        <sch:assert role="error" test="child::element()[1][local-name() = 'scoreDef']">An mei:section embedded into TEI needs to have a scoreDef as first child.</sch:assert>                                
                     </sch:rule>
                  </constraint>
               </constraintSpec>        
            </elementSpec>
            
            <!-- changing Schematron rule -->
            <!-- TODO: This is a temporary fix -->
            <classSpec ident="att.responsibility" module="MEI.shared" type="atts" mode="change">
               <desc xml:lang="en">Attributes capturing information regarding responsibility for some aspect of the text's creation, transcription, editing, or encoding.</desc>
               <attList>
                  <attDef ident="resp" usage="opt" mode="change">
                     <desc xml:lang="en">Indicates the agent(s) responsible for some aspect of the text’s transcription, editing, or encoding. Its value must point to one or more identifiers declared in the document header.</desc>
                     <datatype maxOccurs="unbounded">
                        <rng:ref name="data.URI"/>
                     </datatype>
                     <constraintSpec ident="check_respTarget" scheme="schematron" mode="change">
                        <constraint>
                           <sch:rule context="@resp">
                              <sch:assert role="warning" test="not(normalize-space(.) eq '')">@resp attribute should have content.</sch:assert>
                              <sch:assert role="warning" test="(every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*[ancestor::mei:meiHead]/@xml:id) or . = '#bw_jk'">The value in @resp should correspond to the @xml:id attribute of an element within the metadata header, or reference #bw_jk.</sch:assert>
                           </sch:rule>
                        </constraint>
                     </constraintSpec>
                  </attDef>
               </attList>
            </classSpec>
            
            
            <!-- Disable mensural- and neume-specific model classes in the shared module -->
            <classSpec ident="model.sectionPart.mensuralAndNeumes" module="MEI.shared" type="model"
               mode="delete"/>
            <classSpec ident="model.staffPart.mensuralAndNeumes" module="MEI.shared" type="model"
               mode="delete"/>
            <classSpec ident="model.layerPart.mensuralAndNeumes" module="MEI.shared" type="model"
               mode="delete"/>
            
            <classSpec type="atts" ident="att.linking" module="MEI.shared" mode="change">
               <attList>
                  <attDef ident="corresp" usage="opt" mode="change">
                     <constraintSpec ident="check_correspTarget" scheme="schematron" mode="replace">
                        <constraint>
                           <sch:rule context="@corresp">
                              <sch:assert role="warning" test="not(normalize-space(.) eq '')">@corresp attribute should have content.</sch:assert>
                              <sch:assert role="warning" test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id or matches($i, '^([a-z]+://|\.{1,2}/)')">Each value in @corresp should correspond to the @xml:id attribute of an element or be an external URL.</sch:assert>
                           </sch:rule>
                        </constraint>
                     </constraintSpec>
                  </attDef>
               </attList>
            </classSpec>
            
            <!-- Move model.noteModifierLike from layerPart.mensuralAndNeumes to editTransPart.music -->
            <classSpec ident="model.noteModifierLike" module="MEI.shared" type="model" mode="replace">
               <desc>Groups elements that modify note-like features.</desc>
               <classes>
                  <memberOf key="model.editTransPart.music"/>
               </classes>
            </classSpec>
            
            <macroSpec ident="macro.metaLike.page" module="MEI.shared" mode="delete"/>
            
            <!-- allow @facs references to SVG shapes -->
            <classSpec ident="att.facsimile" module="MEI.facsimile" type="atts" mode="replace">
               <desc>Attributes that associate a feature corresponding with all or part of an image.</desc>
               <attList org="group">
                  <attDef ident="facs" usage="opt">
                     <desc>Permits the current element to reference a facsimile surface or image zone which corresponds to it.</desc>
                     <datatype maxOccurs="unbounded" minOccurs="1">
                        <rng:ref name="data.URI" />
                     </datatype>
                     <constraintSpec ident="check_facsTarget" scheme="schematron" mode="replace">
                        <constraint>
                           <sch:rule context="@facs">
                              <sch:let name="fileClasses" value="tokenize(normalize-space(ancestor::mei:mei//mei:encodingDesc/@class))"/>
                              <sch:let name="isDocFile" value="'#bw_document_file' = $fileClasses"/>
                              <sch:let name="isDt" value="'#bw_diplomatic_transcript' = $fileClasses"/>
                              <sch:let name="isAt" value="'#bw_annotated_transcript' = $fileClasses"/>
                              
                              <sch:assert role="error" test="not($isDocFile)">Document files must not use the @facs attribute.</sch:assert>
                              <sch:assert role="error" test="not($isAt)">Annotated transcripts must not use the @facs attribute. For referencing the corresponding notes in a diplomatic transcript, use @corresp instead.</sch:assert>
                              <sch:assert role="warning" test="not(normalize-space(.) eq '')">@facs attribute should have content.</sch:assert>
                              <sch:assert role="warning" test="normalize-space(.) = .">@facs should use normalized space</sch:assert>
                              <!--<sch:assert role="warning" test="(every $i in tokenize(., '\s+') satisfies substring($i,2)=(//mei:surface/@xml:id, //mei:zone/@xml:id, //svg:path/@id)) or
                                 ancestor::mei:mei//mei:encodingDesc['#bw_module3_textFile' = tokenize(@class,' ')]">Each value in @facs should correspond to the @xml:id attribute of a surface or zone element, or to an svg:shape's @id attribute.</sch:assert>-->
                              <sch:assert role="error" test="not($isDt) or (every $i in tokenize(., '\s+') satisfies starts-with($i, '../svg/'))">In diplomatic transcripts, @facs must point to a separate SVG file (link starting with '../svg/').</sch:assert>
                           </sch:rule>
                        </constraint>
                     </constraintSpec>
                  </attDef>
               </attList>
            </classSpec>
            
            <elementSpec ident="unknownFoliation" module="MEI.header" mode="add" prefix="bw_" ns="https://www.beethovens-werkstatt.de/ns/mei/proposal">
               <desc xml:lang="en">Captures two subsequent surfaces for which the foliation / binding is unknown.</desc>
               <classes>
                  <memberOf key="att.common"/>
                  <memberOf key="att.dimensions"/>
                  <memberOf key="att.measurement"/>
                  <memberOf key="att.foliumSurfaces"/>
                  <memberOf key="model.foliumLike"/>
               </classes>
               <content>
                  <rng:zeroOrMore>
                     <rng:ref name="model.paperModLike"/>
                  </rng:zeroOrMore>
               </content>
               <remarks xml:lang="en">
                  <p>When the exact folium setup can't be identified, it is advised to use <gi scheme="MEI">folium</gi> elements only (and not guess about the presence of <gi scheme="MEI">bifolium</gi>s in the document).</p>
               </remarks>
            </elementSpec>
                        
            <elementSpec ident="layout" module="MEI.msDesc" mode="change">
               <desc xml:lang="en">Describes how text is laid out on the page, including information about any ruling, pricking, or other evidence of page-preparation techniques.</desc>
               <!--<classes>
                  <memberOf key="att.common"/>
                  <memberOf key="att.bibl"/>
                  <memberOf key="att.lang"/>
               </classes>-->
               <content>
                  <rng:choice>
                     <rng:ref name="macro.struc-unstrucContent"/>
                     <rng:ref name="bw_rastrumDesc"/>
                  </rng:choice>
                  <rng:ref name="macro.struc-unstrucContent"/>
               </content>
               <!--<attList>
                  <attDef ident="cols" usage="opt">
                     <desc xml:lang="en">Specifies the number of columns per page.</desc>
                     <datatype minOccurs="1" maxOccurs="2">
                        <rng:data type="nonNegativeInteger"/>
                     </datatype>
                     <remarks xml:lang="en">
                        <p>A single number indicates that all pages have this number of columns. Two numbers mean that the number of columns per page varies between the values supplied.</p>
                     </remarks>
                  </attDef>
                  <attDef ident="ruledlines" usage="opt">
                     <desc xml:lang="en">Specifies the number of ruled text lines per column.</desc>
                     <datatype minOccurs="1" maxOccurs="2">
                        <rng:data type="nonNegativeInteger"/>
                     </datatype>
                     <remarks xml:lang="en">
                        <p> A single number indicates that all columns have this number of ruled lines. Two numbers mean that the number of text lines per column varies between the values supplied.</p>
                     </remarks>
                  </attDef>
                  <attDef ident="writtenlines" usage="opt">
                     <desc xml:lang="en">Specifies the number of written text lines per column.</desc>
                     <datatype minOccurs="1" maxOccurs="2">
                        <rng:data type="nonNegativeInteger"/>
                     </datatype>
                     <remarks xml:lang="en">
                        <p>A single number indicates that all columns have this number of written text lines. Two numbers mean that the number of text lines per column varies between the values supplied.</p>
                     </remarks>
                  </attDef>
                  <attDef ident="ruledstaves" usage="opt">
                     <desc xml:lang="en">Specifies the number of ruled staves per column.</desc>
                     <datatype minOccurs="1" maxOccurs="2">
                        <rng:data type="nonNegativeInteger"/>
                     </datatype>
                     <remarks xml:lang="en">
                        <p>A single number indicates that all columns have this number of ruled staves. Two numbers mean that the number of ruled staves per column varies between the values supplied.</p>
                     </remarks>
                  </attDef>
                  <attDef ident="writtenstaves" usage="opt">
                     <desc xml:lang="en">Specifies the number of written staves per column.</desc>
                     <datatype minOccurs="1" maxOccurs="2">
                        <rng:data type="nonNegativeInteger"/>
                     </datatype>
                     <remarks xml:lang="en">
                        <p>A single number indicates that all columns have this number of written staves. Two numbers mean that the number of written staves per column varies between the values supplied.</p>
                     </remarks>
                  </attDef>
               </attList>-->
               <remarks xml:lang="en">
                  <p>The model of this element is based on the <ref target="https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-layout.html">layout</ref> element of the Text Encoding Initiative (TEI).</p>
               </remarks>
            </elementSpec>
            
            <elementSpec ident="rastrumDesc" module="MEI.msDesc" mode="add" prefix="bw_" ns="https://www.beethovens-werkstatt.de/ns/mei/proposal">
               <desc xml:lang="en">Describes the use of rastrums on a given (set of) page(s).</desc>
               <classes>
                  <memberOf key="att.common"/>
               </classes>
               <content>
                  <rng:zeroOrMore>
                     <rng:ref name="model.rastrumLike"/>
                  </rng:zeroOrMore>
               </content>
            </elementSpec>
            
            <elementSpec ident="rastrum" module="MEI.msDesc" mode="add"  prefix="bw_" ns="https://www.beethovens-werkstatt.de/ns/mei/proposal">
               <desc xml:lang="en">Describes a rastrum used to prepare a page with staff lines.</desc>
               <classes>
                  <memberOf key="att.common"/>
                  <memberOf key="model.rastrumLike"/>
                  <memberOf key="att.rastrum.log"/>
                  <memberOf key="att.rastrum.vis"/>
                  <memberOf key="att.rastrum.ges"/>
                  <memberOf key="att.rastrum.anl"/>
               </classes>
               <content>
                  <rng:empty/>
               </content>
               <constraintSpec ident="Check_rastrum" scheme="schematron">
                  <constraint>
                     <sch:rule context="mei:rastrum">
                        <sch:assert test="not(@systems = '1' and exists(@system.dist))">A rastrum with only one system must not specify a distance between multiple systems.</sch:assert>
                     </sch:rule>
                  </constraint>
               </constraintSpec>
               <remarks xml:lang="en">
                  <p>A rastrum is a traditional tool used to draw staff lines on paper. It may draw one or more systems at a time.
                     The rastrum element tries to reflect this. It is most useful when describing manuscripts, even when they use
                     industrially produced paper. One rastrum element is used per block of systems / staff lines that are produced 
                     simultaneously. The <att>systems</att> attribute indicates the number of systems produced by this rastrum, 
                     while <att>system.height</att> and <att>system.dist</att> describe the height of and distance between these
                     systems.</p>
                  <p>In oder to achieve compatibility with traditional printed source descriptions, it is highly recommended to 
                     provide all measurements in real-world units, like millimeters.</p>
               </remarks>
            </elementSpec>
            
            <classSpec ident="model.rastrumLike" type="model" module="MEI.msDesc" mode="add">
               <desc xml:lang="en">Groups elements describing the rastrum.</desc>
            </classSpec>
            
            <classSpec ident="att.rastrum.log" type="atts" module="MEI.shared" mode="add">
               <desc xml:lang="en">Attributes that capture logical domain information about rastrums.</desc>
               <classes>
                  <memberOf key="att.systemCount"/>
               </classes>
            </classSpec>
            
            <classSpec ident="att.rastrum.vis" type="atts" module="MEI.visual" mode="add">
               <desc xml:lang="en">Attributes that capture rastrum layout information.</desc>
               <classes>
                  <memberOf key="att.systems"/>
                  <memberOf key="att.dimensions"/>
                  <memberOf key="att.systemDistance"/>
                  <memberOf key="att.systemHeight"/>
               </classes>
               <attList>
                  <attDef ident="rotate">
                     <desc xml:lang="en"> Indicates the amount by which the rastrum is rotated relative to the page. Origin of rotation is the top left or the rastrum, i.e. the left end of the top staff line. The orientation is expressed in arc degrees. </desc>
                     <datatype minOccurs="1" maxOccurs="1">
                        <rng:ref name="data.DEGREES"/>
                     </datatype>
                     <defaultVal>0</defaultVal>
                     <remarks xml:lang="en">
                        <p>This attribute is based on the TEI attribute of the same name.</p>
                     </remarks>
                  </attDef>
               </attList>
            </classSpec>
            
            <classSpec ident="att.rastrum.ges" type="atts" module="MEI.gestural" mode="add">
               <desc xml:lang="en">Attributes that capture rastrum performance information.</desc>
            </classSpec>
            
            <classSpec ident="att.rastrum.anl" type="atts" module="MEI.analytical" mode="add">
               <desc xml:lang="en">Attributes that capture analytical information about rastrums.</desc>
            </classSpec>
            
            <classSpec ident="att.systemDistance" type="atts" module="MEI.visual" mode="add">
               <desc xml:lang="en">Attributes describing the distance between systems.</desc>
               <attList>
                  <attDef ident="system.dist" usage="opt">
                     <desc xml:lang="en">Describes the distance between two adjacent sets of staff lines.</desc>
                     <datatype>
                        <rng:ref name="data.MEASUREMENTUNSIGNED"/>
                     </datatype>
                  </attDef>
               </attList>
            </classSpec>
            
            <classSpec ident="att.systemHeight" type="atts" module="MEI.visual" mode="add">
               <desc xml:lang="en">Attributes describing the height of a set of staff lines.</desc>
               <attList>
                  <attDef ident="system.height" usage="opt">
                     <desc xml:lang="en">Describes the height of a set of staff lines.</desc>
                     <datatype>
                        <rng:ref name="data.MEASUREMENTUNSIGNED"/>
                     </datatype>
                  </attDef>
               </attList>
            </classSpec>
            
            <classSpec ident="att.systemCount" type="atts" module="MEI.shared" mode="add">
               <desc xml:lang="en">Attributes describing the of number of staves.</desc>
               <attList>
                  <attDef ident="systems" usage="opt">
                     <desc xml:lang="en">The number of systems / staves on a page.</desc>
                     <datatype minOccurs="1" maxOccurs="2">
                        <rng:data type="nonNegativeInteger"/>
                     </datatype>
                  </attDef>
               </attList>
            </classSpec>
            
            <!-- All Schematron rules are gathered here for better orientation. -->
            <elementSpec ident="mei" module="MEI.shared" mode="change">
               <constraintSpec ident="check-mei-id" scheme="schematron" mode="add">
                  <constraint>
                     <sch:rule context="mei:mei">
                        <sch:assert test="@xml:id">An mei file must have an id</sch:assert>
                     </sch:rule>
                     
                     <sch:rule context="mei:bifolium/@*[local-name() = ('outer.recto', 'inner.verso', 'inner.recto', 'outer.verso')]">
                        <sch:let name="uri" value="string(.)"/>
                        <sch:let name="localLink" value="starts-with($uri, '#')"/>
                        
                        <sch:let name="id" value="substring-after($uri, '#')"/>
                        
                        <sch:let name="localElem" value="root()/id($id)"/>
                        <sch:let name="localRef" value="exists($localElem) and local-name($localElem) eq 'surface'"/>
                        
                        <sch:let name="file" value="substring-before($uri, '#')"/>
                        <sch:let name="path" value="string-join(tokenize(document-uri(root()), '/')[position() lt last()], '/') || '/'"/>
                        
                        <sch:let name="remoteRef" value="doc-available($path || $file) and exists(doc($path || $file)/id($id)) and local-name(doc($path || $file)/id($id)) eq 'surface'"/>
                        
                        <sch:assert test="$localRef or $remoteRef"><sch:value-of select="local-name()"/> must point to a surface element, either locally or in a different source document.</sch:assert>
                     </sch:rule>
                     <sch:rule context="mei:folium/@*[local-name() = ('recto', 'verso')]">
                        <sch:let name="uri" value="string(.)"/>
                        <sch:let name="localLink" value="starts-with($uri, '#')"/>
                        
                        <sch:let name="id" value="substring-after($uri, '#')"/>
                        
                        <sch:let name="localElem" value="root()/id($id)"/>
                        <sch:let name="localRef" value="exists($localElem) and local-name($localElem) eq 'surface'"/>
                        
                        <sch:let name="file" value="substring-before($uri, '#')"/>
                        <sch:let name="path" value="string-join(tokenize(document-uri(root()), '/')[position() lt last()], '/') || '/'"/>
                        
                        <sch:let name="remoteRef" value="doc-available($path || $file) and exists(doc($path || $file)/id($id)) and local-name(doc($path || $file)/id($id)) eq 'surface'"/>
                        
                        <sch:assert test="$localRef or $remoteRef"><sch:value-of select="local-name()"/> must point to a surface element, either locally or in a different source document.</sch:assert>
                     </sch:rule>
                     
                     <!-- make sure a file has a type -->
                     <sch:rule context="mei:meiHead">
                        <sch:assert test="mei:encodingDesc">Each MEI file needs to have an encodingDesc.</sch:assert>
                     </sch:rule>
                     <sch:rule context="mei:encodingDesc">
                        <sch:assert test="@class">Each encodingDesc needs to identify the right type of file using @class.</sch:assert>
                     </sch:rule>
                     
                     <!-- make sure a file is of proper type -->
                     <sch:rule context="mei:encodingDesc/@class">
                        <sch:let name="classes" value="tokenize(normalize-space(.),' ')"/>
                        <sch:let name="doc" value="'#bw_document_file' = $classes"/>
                        <sch:let name="dt" value="'#bw_diplomatic_transcript' = $classes"/>
                        <sch:let name="at" value="'#bw_annotated_transcript' = $classes"/>
                        <sch:assert test="$doc or $dt or $at">This MEI file does not specify its type correctly. Should be either '#bw_document_file', '#bw_annotated_transcript', or '#bw_diplomatic_transcript'.</sch:assert>
                        <sch:assert test="not(($doc and $dt) or ($doc and $at) or ($dt and $at))">This MEI file cannot have multiple types simultaneously. Please decide between '#bw_document_file', '#bw_annotated_transcript', and '#bw_diplomatic_transcript'.</sch:assert>
                     </sch:rule>
                     
                     <!-- check for child elements of music -->
                     <sch:rule context="mei:music/mei:*">
                        <sch:let name="fileClasses" value="tokenize(normalize-space(ancestor::mei:mei//mei:encodingDesc/@class))"/>
                        <sch:let name="isDocFile" value="'#bw_document_file' = $fileClasses"/>
                        <sch:let name="isDt" value="'#bw_diplomatic_transcript' = $fileClasses"/>
                        <sch:let name="isAt" value="'#bw_annotated_transcript' = $fileClasses"/>
                        <sch:let name="localName" value="local-name(.)"/>
                        <sch:assert test="not($isDocFile) or ($localName = ('facsimile', 'genDesc'))">A document file may only have facsimile and genDesc child elements, but not <sch:value-of select="$localName"/>.</sch:assert>
                        <sch:assert test="not($isDt) or ($localName = ('body'))">A diplomatic transcript may only have an mei:body as child, but not <sch:value-of select="$localName"/>.</sch:assert>
                        <sch:assert test="not($isAt) or ($localName = ('body'))">An annotated transcript may only have an mei:body as child, but not <sch:value-of select="$localName"/>.</sch:assert>
                     </sch:rule>
                     
                     <!-- check for child elements of mdiv -->
                     <!-- TODO: TEMPORARILY DISABLED, NEEDS TO BE ENABLED AFTER FINISHING WITH MEI-FRIEND -->
                     <!--<sch:rule context="mei:mdiv">
                        <sch:let name="fileClasses" value="tokenize(normalize-space(ancestor::mei:mei//mei:encodingDesc/@class))"/>
                        <sch:let name="isDocFile" value="'#bw_document_file' = $fileClasses"/>
                        <sch:let name="isDt" value="'#bw_diplomatic_transcript' = $fileClasses"/>
                        <sch:let name="isAt" value="'#bw_annotated_transcript' = $fileClasses"/>
                        <sch:let name="label" value="if($isDt) then('diplomatic') else if($isAt) then('annotated') else ('')"/>
                        <sch:assert test="if($isDt or $isAt) then(exists(mei:drafts) and count(child::mei:*) = 1) else(true())">A <sch:value-of select="label"/> transcript must have a drafts child element.</sch:assert>
                     </sch:rule>-->
                     
                     <!-- check events in diplomatic transcripts -->
                     <sch:rule context="mei:note/@*">
                        <sch:let name="fileClasses" value="tokenize(normalize-space(ancestor::mei:mei//mei:encodingDesc/@class))"/>
                        <sch:let name="isDt" value="'#bw_diplomatic_transcript' = $fileClasses"/>
                        <sch:let name="forbiddenAttributes" value="('pname', 'oct', 'dur', 'dur.ges', 'oct.ges', 'dots', 'dots.ges')"/>
                        <sch:let name="localName" value="local-name(.)"/>
                        <sch:assert test="not($isDt) or not($localName = $forbiddenAttributes)">In diplomatic transcripts, notes may not use the <sch:value-of select="$localName"/> attribute.</sch:assert>
                     </sch:rule>
                     
                     <!-- check notes in both types of transcripts -->
                     <sch:rule context="mei:note">
                        <sch:let name="fileClasses" value="tokenize(normalize-space(ancestor::mei:mei//mei:encodingDesc/@class))"/>
                        <sch:let name="isDt" value="'#bw_diplomatic_transcript' = $fileClasses"/>
                        <sch:let name="isAt" value="'#bw_diplomatic_transcript' = $fileClasses"/>
                        <sch:let name="requiredAttributesDt" value="('id', 'loc', 'coord.x1', 'facs')"/>
                        <sch:let name="requiredAttributesAt" value="('id', 'pname', 'oct')"/>
                        <sch:assert test="not($isDt) or (every $att in $requiredAttributesDt satisfies exists(@*[local-name(.) eq $att]))">In diplomatic transcripts, every note is required to have all of the <sch:value-of select="string-join($requiredAttributesDt, ', ')"/> attributes.</sch:assert>
                        <sch:assert test="not($isAt) or (every $att in $requiredAttributesAt satisfies exists(@*[local-name(.) eq $att]))">In annotated transcripts, every note is required to have all of the <sch:value-of select="string-join($requiredAttributesAt, ', ')"/> attributes.</sch:assert>
                     </sch:rule>
                     
                     <!-- rules for annotated transcripts -->
                     <sch:rule context="mei:tie">
                        <sch:assert test="@curvedir">Every tie needs a curvedir attribute.</sch:assert>
                     </sch:rule>
                     <sch:rule context="mei:slur">
                        <sch:assert test="@curvedir">Every slur needs a curvedir attribute.</sch:assert>
                     </sch:rule>
                     
                     <sch:rule context="mei:dynam">
                        <sch:assert test="@place">Every dynam needs a place attribute.</sch:assert>
                     </sch:rule>
                     <sch:rule context="mei:artic">
                        <sch:assert test="@place">Every artic needs a place attribute.</sch:assert>
                     </sch:rule>
                     <sch:rule context="mei:fermata">
                        <sch:assert test="@place">Every fermata needs a place attribute.</sch:assert>
                     </sch:rule>
                     <sch:rule context="mei:harm">
                        <sch:assert test="@place">Every harm needs a place attribute.</sch:assert>
                     </sch:rule>
                     <sch:rule context="mei:hairpin">
                        <sch:assert test="@place">Every hairpin needs a place attribute.</sch:assert>
                     </sch:rule>
                     <sch:rule context="mei:octave">
                        <sch:assert test="@dis.place">Every octave needs a dis.place attribute.</sch:assert>
                     </sch:rule>
                     <sch:rule context="mei:dir">
                        <sch:assert test="@place">Every dir needs a place attribute.</sch:assert>
                     </sch:rule>
                     <sch:rule context="mei:syl">
                        <sch:assert test="@place">Every syl needs a place attribute.</sch:assert>
                     </sch:rule>
                     <sch:rule context="mei:tempo">
                        <sch:assert test="@place">Every tempo needs a place attribute.</sch:assert>
                     </sch:rule>
                     <sch:rule context="mei:trill">
                        <sch:assert test="@place">Every trill needs a place attribute.</sch:assert>
                     </sch:rule>
                  </constraint>
               </constraintSpec>
            </elementSpec>

            <elementSpec ident="mdiv" module="MEI.shared" mode="change">
               <content>
                  <rng:choice>
                     <rng:group>
                        <rng:optional>
                           <rng:ref name="model.scoreLike"/>
                        </rng:optional>
                        <rng:optional>
                           <rng:ref name="model.partsLike"/>
                        </rng:optional>
                        <rng:optional>
                           <rng:ref name="model.draftsLike"/>
                        </rng:optional>
                        <rng:optional>
                           <rng:ref name="bw_proposal"/>
                        </rng:optional>
                     </rng:group>
                  </rng:choice>
               </content>
               <remarks xml:lang="en">
                  <p>In Beethovens Werkstatt, the <gi scheme="MEI">mdiv</gi> element may contain <gi>drafts</gi>, but may not be nested.</p>
               </remarks>
            </elementSpec>
            
            <classSpec ident="model.draftsLike" type="model" module="MEI.genetic" mode="add">
               <desc xml:lang="en">Groups elements similar to drafts containers.</desc>
            </classSpec>
            
            <elementSpec ident="drafts" module="MEI.genetic" mode="add" prefix="bw_" ns="https://www.beethovens-werkstatt.de/ns/mei/proposal">
               <desc>Provides a container for drafts.</desc>
               <classes>
                  <memberOf key="att.common"/>
                  <memberOf key="att.declaring"/>
                  <memberOf key="model.draftsLike"/>
               </classes>
               <content>
                  <rng:zeroOrMore>
                     <rng:ref name="model.draftLike"/>
                  </rng:zeroOrMore>
               </content>
            </elementSpec>

            <classSpec ident="model.draftLike" type="model" module="MEI.genetic" mode="add">
               <desc xml:lang="en">Groups elements similar to drafts.</desc>
            </classSpec>

            <elementSpec ident="draft" module="MEI.genetic" mode="add" prefix="bw_" ns="https://www.beethovens-werkstatt.de/ns/mei/proposal">
               <desc>A version of the musical content that is unfinished – a sketch, draft or similar.</desc>
               <classes>
                  <memberOf key="att.common"/>
                  <memberOf key="att.declaring"/>
                  <memberOf key="att.trans"/>
                  <memberOf key="model.draftLike"/>
               </classes>
               <content>
                  <rng:zeroOrMore>
                     <rng:choice>                 
                        <rng:ref name="model.annotLike"/>
                        <rng:ref name="model.appLike"/>
                        <rng:ref name="model.divLike"/>
                        <rng:ref name="model.editLike"/>
                        <rng:ref name="model.graphicPrimitiveLike"/>
                        <rng:ref name="model.milestoneLike.music"/>
                        <rng:ref name="model.relationLike"/>
                        <rng:ref name="model.scoreDefLike"/>
                        <rng:ref name="model.scorePart"/>
                        <rng:ref name="model.staffDefLike"/>
                        <rng:ref name="model.transcriptionLike"/>
                     </rng:choice>
                  </rng:zeroOrMore>
               </content>
               <remarks>
                  <p>Drafts may have any kind of score setup – an incomplete particell with multiple staves may 
                     very well be regarded as <gi scheme="MEI">draft</gi>. However, their distinctive incompleteness 
                     is important: It is not possible to map their content 1:1 to a later finished <gi scheme="MEI">score</gi>
                     (or <gi scheme="MEI">part</gi>). Therefore, they allow only selective mapping, which can be done using
                     <gi scheme="MEI">relation</gi>s with <att>rel</att>="isReconfigurationOf" inside the <gi scheme="MEI">genDesc</gi> element.  
                  </p>
               </remarks>
            </elementSpec>
            
            <classSpec ident="att.meiVersion" module="MEI.shared" type="atts" mode="replace">
               <desc xml:lang="en">Attributes that record the version of MEI in use.</desc>
               <attList>
                  <attDef ident="meiversion" usage="opt">
                     <desc xml:lang="en">Specifies a generic MEI version label.</desc>
                     <defaultVal>6.0+beethovensWerkstatt</defaultVal>
                     <valList type="closed">
                        <valItem ident="6.0+beethovensWerkstatt">
                           <desc xml:lang="en">MEI 6.0 with customizations by Beethovens Werkstatt</desc>
                        </valItem>
                     </valList>
                  </attDef>
                  <attDef ident="attribute" usage="opt" ns="https://www.beethovens-werkstatt.de/ns/mei/proposal">
                     <defaultVal>test</defaultVal>
                     <valList type="closed">
                        <valItem ident="test">
                           <desc xml:lang="en">Test attribute in different namespace.</desc>
                        </valItem>
                     </valList>
                  </attDef>
               </attList>
            </classSpec>
         </schemaSpec>
      </body>
   </text>
</TEI>
